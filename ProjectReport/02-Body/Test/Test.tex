\section{Test}
\label{sec:Test}

Testing a compiler like the \lang{} compiler is a none trivial task to
accomplish. Ideally, one would have unit testing implemented for each process in the
compiler as well as integration tests between the different processes to ensure
to minimize and catch potential issues which critical for a compiler as it would
be impossible for a developer to debug their own code if they cannot trust the
behaviour of the language. \\

There are some impracticalities in unit-testing each process in the \lang{} compiler
which are severe enough that their cost-benefit is deemed too step a price for this
project. The following sections are dedicated to justifying these missing tests and
lastly we will go over the final testing results.

\subsection{Testing Issues}

There are several issues that makes it excessively difficult to test each section of
the \lang{} compiler separately. This means that only two types of tests can be
performed; static analysis and full pipeline testing. 

\subsubsection{Lexial Analysis Testing}

The \lexer{} is not inherently difficult to test - to do so one could write a program
and run the \lexer{} against the code. The we could test the resulting Token Stream
against some expected token stream. If the two streams match then would might deem
such a test successful. \\

The issue here lies in the space of possible combinations of tokens is virtually
infinite and so it becomes impractical to write a sufficient number of tests to
confirm that behavour of the \lexer{}.

\subsubsection{Parser Testing}

The \parser{} suffers from similar issues to testing as the \lexer. In theory we can
parse a test program, and build by hand a \ast{} to represent the expected \ast{}
if the two tree structures match, then we can pass the test. \\ 

The issue once again lies in the impractical amount of time, which it would take to
manually craft the \ast{} of different test programs. Further adding to the
impractically is the fact that this process is much more error prone than that of the
\lexer. As the test cases become more complex to cover different edge cases the
chance that a test is failing due to a bug in the test itself increases
exponentially.

\subsubsection{Static Analysis Testing}
\label{sec:testStatic}

Static Code analysis turns out to be quite feasible to perform and thus several tests
have been written to test this section of the \static. Here we can simply parse a
test program through the \lexer{} and the \parser{} then once the type checking and
borrow checking visitors analize the \ast{} we can simply assert whether or not the
visitors are expected to throw an error.

Their are some issues here in regards to the \typeChecker{} which makes it possible
to only do limited testing on this process. 

One kind of tests are to run similar tests as the \borrowChecker{} and simply
asserting if certain programs are valid from the standpoint of \typeChecker. The
This approach is possible, but it offers only incomplete insight into the
\typeChecker{}. This is because the \typeChecker actively modifies the state of the
\ast{} on which it operates mening that the aformentioned tests are incomplete as
they only tell us if compilation will stop due to the \typeChecker{} it does not tell
us if the \typeChecker{} correctly identified the different types and correctly
assigned them to their respective expressions.

To achieve the last from of testing, one would run into similar problems as those
encountered when testing the parser itself, in that one would have to manually craft
\ast s for testing and manually assign the types for all their expressions.

\subsubsection{Code Generator Testing}

Testing the \codeGen{} carries different impracticalities. It would still be
extremely time consuming to write the expected IR of any test program, but there are
different issues at play as well. 

One the LLVM backend converts an \ast{} into an LLVM IR code, it performs certain
optimizations - These optimizations make it virtually impossible to write any IR
testing because it is uncertain what optimizations can be expected by LLVM.

\subsection{Testing Results}

When testing the \borrowChecker{} as described in Section~\ref{sec:testStatic} it
becomes clear that the \borrowChecker{} works in most intended use cases. There is
currently one failing test, which is closely related to the issues discussed in
section~\ref{sec:BorrowCheckerImpl}, talking about the \borrowChecker's issues in
regards to accurately tracking ownership when variables are passed to functions as
parameters.

\begin{figure}[ht]
  \includegraphics[width=1\linewidth]{02-Body/Test/Failing\_test.png}
  \caption{Shows the state of testing in the \lang{} compiler. Currently one test is
  failing, which relate to the issues that the borrow checker had with tracking
ownership (see Section~\ref{sec:BorrowCheckerImpl})}
  \label{fig:failTest}
\end{figure}

Ideally, it would have been prefered to be able to write test cases more
independently for each process, but this was not practically feasible and so this was
the only testing performed besides manual testing, which involved writting programs
and then printing their outputs to standard output to see if the programs performed
as expected.

