\subsection{Code Generator}
\label{sec:CodeGenImplement}
This is where the visitor pattern truly comes into its own. Whereas the borrow and type checker each performs limited operations on each node, which could feasibly be performed by e.g. the nodes constructors, the code generator is sufficiently complicated that it requires its own structure to avoid loosing the overview. This is of course beside any consideration of coding principles.\\
When writing the code generator we have taken inspiration from the LLVM tutorial language Kaleidoscope \cite{LLVMTutorial} to see how to set up boilerplate and as a starting point when looking for the correct LLVM function.

\subsubsection{LLVM}
LLVM works with three important components: a Builder, a Context and a Module. The Builder provides an API to create the program instructions, the Context manages the core global data (types, code blocks and program instructions created by the builder), while the Module stores the functions.


\paragraph*{Variables}
When the Builder creates a program instruction, it usually returns an llvm::Value type. It is possible to store these in a symbol table and access them later, but because LLVM creates a static single assignment IR, it is not possible to change the value of the stored variables. To get around this we create an allocation instance (llvm::AllocaInst), which can hold an llvm::Value. We can then store new llvm::Values in the same llvm::AllocaInst, obtaining mutable variables.

\paragraph*{Code blocks and functions}


\subsubsection{Scope and variables}
Storing variables 
We want to be able to create variables with the same name as long as they are not in the same scope. 

\subsubsection{Output}
Implementing an output posed a new type of challenge, as writing an output is not the responsibility of the compiler, but rather the operating system. As such the challenge went from finding the correct LLVM method to finding out how to use external functions in our program. Because an output is not strictly necessary to answer our problem statement, but more a quality of life, it did become a quick and unappealing implementation, that needs refinement.\\
The first way to output elements from our  program involved another programming language (C). The fact that we compile to a .o file allowed us to write our functions, and then link the .o file to a C program that would call the \lang{} functions and print their output with the C implementation of printf(). A workable, but unsatisfying solution, that allowed us to test the compiler. The next step was to bring printf() into \lang. Because our focus is on memory and type safety, the print function implementation became a hard coded reference to printf() with the specific formatting required to print our types.\\
This works only because we already compile with libc linked in the GCC compiler (it is how the main function is called), as this library contains the printf() function. It is also necessary to turn off position independent execution (PIE), to reach the printf() function. This introduces a small security risk (in case of a buffer overflow attack), which is entirely mitigated by the lack of user input. significant amounts of additional work is required to bring the current output up to a good state (such as allowing PIE, making print() not be hard coded, and implementing an input in a similar manner).

