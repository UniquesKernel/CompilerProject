\subsection{Borrow Checker}
\label{sec:BorrowCheckerDesign}

The \borrowChecker{} implements the visitor pattern (see
section~\ref{sec:VisitorDesign}) and uses this to traverse the \ast{} in a depth first
left to right pattern. It uses two tables a \texttt{symbolTable} and a
\texttt{referenceTable} to keep track of the scope and the
references of each variable.

\newpage

\begin{lstlisting}[
  frame=single,
  numbers=left,
  label={lst:BorrowCheckerCode},
  caption={Example Program to illustrate how the borrow checker is designed   to walk the \ast{} and use tables to keep track of references},
  ]
  fn main(): int {
    let mut x: int = 1;
    let y: &int = &mut x;
    let z: &int = &x;
    return 0;
  }
\end{lstlisting}

Consider the example program (see Listing~\ref{lst:BorrowCheckerCode}) and the
accomanying subtree (see Figure~\ref{fig:astBorrowCheckerDesignCode}). The borrow checker visits each node
in a depth-first order and at each point it determines based on \texttt{symbolTable}
and the \texttt{referenceTable} if the
program is in compliance with the ownership, borrowing and reference rules (see
section~\ref{par:Ownership}).

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}

    \node[draw] (program) at (0,0){Program Expression};

    \node[draw] (main) at (0,-1){main};

    \node[draw] (assign) at (-3, -2){=};
    \node[draw] (x) at (-4, -3){x};
    \node[draw] (term) at (-2, -3){1};

    \draw[] (program) -- (main);
    \draw[] (main) -- node[above]{3} (assign);
    \draw[] (assign) -- node[left]{1} (x);
    \draw[] (assign) -- node[right]{2} (term);

    \node[draw] (assign2) at (0, -2){=};
    \node[draw] (y) at (-1, -3){y};
    \node[draw] (ref) at (1, -3){\&x};

    \draw[] (main) -- node[left]{6} (assign2);
    \draw[] (assign2) -- node[left]{4} (y);
    \draw[] (assign2) -- node[right]{5} (ref);

    \node[draw] (assign3) at (3, -2){=};
    \node[draw] (z) at (2, -3){z};
    \node[draw] (ref2) at (4, -3){\&x};

    \draw[] (main) -- node[above]{9} (assign3);
    \draw[] (assign3) -- node[left]{7} (z);
    \draw[] (assign3) -- node[right]{8} (ref2);

  \end{tikzpicture}
  \caption{Program \ast{} ignoring the return statement. The numbering showing the
  order that the \borrowChecker{} proccess each node.}
  \label{fig:astBorrowCheckerDesignCode}
\end{figure}

In our example prgram, the \borrowChecker{} will add the \texttt{x} variable to the
symbol table. When it creates a reference to \texttt{x}, it will look up \texttt{x} to ensure
it is an existing variable that can be referenced, then it will store \texttt{y} in the symbolTable as
well as a reference in the \texttt{referenceTable} to determine if future
references are legal to perform. 
Once it reaches the last instruction it will look up \texttt{x} in the
symbolTable, which is fine, but it will determine from the
\texttt{referenceTable} that a mutable reference already exists and thus the last
instruction is an illegal operation as immutable and mutable references cannot
exist at the same time (see Section~\ref{par:Ownership}) and inform
the user that the program is not a valid \lang{} program.
