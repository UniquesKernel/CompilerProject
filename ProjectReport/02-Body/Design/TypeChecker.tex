\subsection{\typeChecker{}}
\label{sec:typeCheckerDesign}
The \typeChecker{} implements a visitor (see section \ref{sec:VisitorDesign}). 
Because its primary purpose is to ensure type safety, the main part of the expression
nodes that it accesses is the type field. It of course also accesses the children of
the nodes.\\

The type of the nodes will be verified using the following rules:
\begin{enumerate}

\item All nodes has the type of their children with following exceptions:
\begin{enumerate}
\item Terminal expressions and variables determine their own type.
\item Binary expression comparisons ($<$, $>$, $==$ and $!=$) are type \textit{bool}.
\item Binary expressions involving references are primitive types and not reference
  types.
\item Blocks are the type of their return statements. 
\item If statements and functions are the type of the block(s).
\end{enumerate}
\item Binary expressions: Both children must be the same type.
\item Binary expressions: References are threated as same type as the
  variable they reference.
\item All return statements in a block must be the same type.
\item If/else statement blocks must be the same type.
\item Variables must be assigned a value of its declared type.
\item The type of a function body must match its declared return type.
\end{enumerate}

The majority of nodes are created without any explicit type (indeed only variable
assignment and terminal expressions can know their own type). This is not immediately
a problem, as the \typeChecker{} is entirely capable of cascading types up through the
tree. It is however sometimes necessary to check the type of an expression at a later
stage of the compile process (eg. in code generation, when allocating space for a
variable). As such we decided that the \typeChecker, since it was already calculating
the type of the node, should save the type to the particular node.

