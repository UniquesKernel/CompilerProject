\subsection{Language Design}
\label{sec:LanguageDesign}

\lang{} is an expression based language. Every language construct, except function
declarations return a value and can be stored in a variable for later use. To achieve
our three main goals of clarity, type safety, and memory safety, \lang{} is designed
to require explicit typing, immutability by default and to enforce the same
borrowing and reference rules as the \texttt{Rust} programming language.\\

Due to time constraints \lang{} does not support multiple files, this constraint
influences the way \lang{} is designed. Unlike scripting languages like
\texttt{Python} and \texttt{JavaScript}, which are capable of running its code without
a dedicated main function \lang{} organizes its code similar to procedural
languages like \texttt{C} in which a main function is required for a standalone
program. \\

Because \lang{} is entirely constrained to a single file its grammar is designed to
help and encourage users to modularize their code through the use of functions but it
also limits its scalability as it becomes impractical to write large application
using \lang{} as this would lead to an unmanagably large file. 

\subsubsection{Language Features}
\label{sec:Grammar}

\lang{} is quite simple, and it's features are heavy inspired by the
\texttt{Rust} language\cite{RUST}, however it is also influenced by its limited feature set and
by the objective of the language as set forth in section~\ref{sec:Objectives}. This
section shall focus on the language design elements which are the most important for
\lang{}.

\begin{figure}[ht]
\centering
\begin{grammar}
<variable-assignment> ::= `KW_VAR' <identifier> `COLON' <type> `=' <expr>
\alt `KW_VAR' `KW_MUT' <identifier> `COLON' <type> `=' <expr>

<function-decl> ::= `FUNCTION' <identifier> `LPAREN' <arg-list> `RPAREN' `COLON' <type> <expr-block>
\end{grammar}
\caption{Shows the production rules used by the \parser{} to parse variable
assignments.}
\label{fig:assingmentRule}
\end{figure}

As can be seen in figure~\ref{fig:assingmentRule} shows a simple example of how
variable assignment and function declarations are defined in the \lang. Variable
assignments uses the
\texttt{let} keyword optionally followed by the \texttt{mut} keyword to determine if
the variable is a mutable variable or not. Next comes the name of the variable
separated by an obligatory colon and the type of the variable. Lastly using the
\texttt{=} operator we specify which expression should be stored in the variable. \\

Function declarations work similarly to how must other languages define functions.
\lang{} uses the \texttt{fn} keyword followed by the function name and a comma
seperated list of arguments in side parenthesis. After this is uses a colon
seperation to define the return type of the function and lastly bracers to encluse
the function body. \\

For a complete language definition see appendix~\ref{sec:appB} which holds a
complete list of all language constructs and their definitions. Furthermore
appendix~\ref{sec:appA} holds the list of tokens used in the production rules and how
they translate to keywords like \texttt{let} and \texttt{mut}.


\paragraph{Explicit Typing} \hfill
\vspace{0.1em}

In \lang{} the declaration of any varialbes require explicit typing. The compiler
must never attempts to infere the type of a variable from its use and so all types
must be known at compile time.\\

The same goes for function declarations. Every function must explicitly be declared
with a return value, so the compiler can simply check the expected return type
against the type of any returned values. listing~\ref{lst:assignmentRule} showcases
how to write a simle main program with variable assignment in accordance with the
rules laied out in figure~\ref{fig:assignmentRule}.

\begin{lstlisting}[
  frame=single,
  caption={
    \lang{} code showing the correct and incorrect way of declaring an immutable
    variable in accordance with the rule in figure~\ref{fig:assingmentRule}.
    },
  label={lst:assignmentRule}
  numbers=left,
  ]
  fn main(): int {
    let x: int = 1; // compiles
    let x = 1; // does not compile
    return 0;
  }
\end{lstlisting}

This ensures clarity, in accordance with the objectives of \lang{}, since a
developer can always read the source code and see which type of data they are working
with.

\paragraph{Immutability by Default} \hfill 
\vspace{0.1em}

Another important feature to ensure clarity in \lang{} is the default immutability of
variables. This ensures that unless explicitly declared by a developer, by using the
\texttt{mut} keyword, a variable
cannot be changed after it's initialization.

\begin{lstlisting}[
  frame=single,
  caption={
    \lang{} code showing the constraints of immutability on variables.
    }, 
    numbers=left
  ]
  fn main(): int {
    let x: int = 1; 
    x = 2; // does not compile as x is immutable

    let mut y: int = 1; 
    y = y + 1; // does compile as y has been declared mutable

    return 0;
  }
\end{lstlisting}

By forcing developers to be explicit about their intend to change data \lang{}
achieves higher clarity and safety in its code. \\ 

A developer in \texttt{C} can create a variable and it might or might not change at
runtime unless a developer prevents it from changing. This is not ideal as a
developer might have intended for a variable to never change but forget to ensure it
by declaring the variable as \texttt{const}. In \lang, however, a developer is protected from
such mistakes as they must be explicit about their intent to change a variable at
runtime and can't do so by accident.

\paragraph{Ownership and Borrowing} \hfill 
\label{par:Ownership}

In order to ensure memory safety without the use of a garbage collector as described
in section~\ref{sec:Objectives} \lang{} enforces the same ownership, borrowing and
reference rules of the \texttt{Rust} language.

\subparagraph{Onwership rules:}
\begin{enumerate}
  \item Each value has an owner\cite{RUST}. 
  \item There can be only one owner at a time\cite{RUST}. 
  \item When the owner goes out of scope the value is dropped\cite{RUST}.
\end{enumerate}

\subparagraph{Borrowing and Referencing:}
\label{par:borrowing}

\begin{enumerate}
  \item At any given time, you can have either one mutable reference or any number of
    immutable references\cite{RUST}.
  \item References must always be valid\cite{RUST}.
\end{enumerate}

To visualize these rules consider Listing~\ref{lst:scope} which portrays how the
rules of ownership functions.

\begin{lstlisting}[
  frame = single,
  caption = {show casing ownership rules in \lang.},
  label = {lst:scope},
  numbers = left
]
fn factorial(n: int): int { // implementation left out for brevity... }

fn main(): int{
  
  {
    let x: int = 1; // x comes into scope

    // do something with x
  } // x goes out of scope

  let x: int = 1; // x comes into scope.
  let y: int = factorial(x); // ownership of x is transfered to factorial.

  // x is no longer in scope and cannot be used.
  print("%i", x); // does not compile

  return 0;
}
\end{lstlisting}

Scopes work like one would expect in most programming languages, as \texttt{x} comes into
scope at line 6 and goes out of scope at line 9. This is as one would expect of
variables and well in line with rules 1 and 3 of the ownership
rules. \\

Lines 11-12, however, shows something interesting regarding the constraints imposed
by ownership rule 2. Because a variable can only have a single owner, when a variable
is parsed to a function, the ownership of the variable is transfered to that function
and goes out of scope along with the function's inner scope, rendering the variable
\texttt{x} unusable afterwards. The variable is moved into the scope of the calling
function similarly to how smart pointers are used in treated in languages like
\texttt{C++} when they are moved between scopes\cite{CPPRef}. Thus the
\texttt{factorial} function is said to take ownership of \texttt{x}.

\lstset{
  escapeinside={(*}{*)}
}
\begin{lstlisting}[
  frame = single,
  caption = { \lang{} code showing how references can be used to avoid transfering
  ownership. }, 
  label = {lst:references},
  numbers = left
]
fn factorial(n: &int): int { // implementation left out for brevity... }

fn main(): int {
  let x: int = 1; // x comes into scope.

  let y: int = factorial(&x); // x is borrowed as a reference.

  printf("%i", x); // ownership is tranfered and x goes out of scope.

  return 0;
}
\end{lstlisting}

If one wishes to parse a variable to a function without moving the ownership into the
function, then we can instead parse a reference of the varaible to the function instead. This is
called borrowing and it allows us to parse into the function a reference to the
memory location of out variable, which the function can follow once it needs the value
of the its input argument. For all practical purposes references are just pointers, but they
are governed by special rules and just as with variables they are immutable unless
explicitly declared to be mutable. \\

The use of references allows \lang{} to be very efficient in its use of memory as
duplication of variables aren't necessary. But it's important to understand that
references do have some limitations in \lang{} as noted in \ref{par:borrowing}. \\

As per the first rule, we can only have either one mutable or any number of immutable references to a
variable. This rule is enforced by \lang{} but not strictly necessary as these rules
are in place to ensure memory safety in concurrent programs to ensure that data isn't
modified by multiple threads or read by one thread while being modified by a second
thread. \\

The second rule is more important for \lang{}, the requirement that references must
always be valid means that functions cannot return references. This is because as per
the rule of ownership a references goes out of bound when it goes out of scope, so if
functions could return references it opens up the possiblity of dangling pointers
which can cause serious security issues if allowed.
